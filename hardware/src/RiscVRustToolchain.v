
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module RiscVRustToolchain(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// RISC-V JTAG (revH or later only) //////////
	input 		          		RISCV_JTAG_TCK,
	input 		          		RISCV_JTAG_TDI,
	output		          		RISCV_JTAG_TDO,
	input 		          		RISCV_JTAG_TMS
);



//=======================================================
//  REG/WIRE declarations
//=======================================================



//=======================================================
//  Structural coding
//=======================================================

    reg [3:0] clk_count = 0;

    // Internal reset signal
    reg resetn = 0;

    // Simple clock cycle counter for periodic reset
    always @(posedge CLOCK_50) begin
        if (clk_count == 10) begin
            clk_count <= clk_count + 1;
            resetn <= 0;         // Assert reset (active-low)
        end 
		else begin
            if(clk_count <=10) clk_count <= clk_count + 1;
            resetn <= 1;         // Deassert reset (normal operation)
        end
	end

    // PicoRV32 memory bus signals
    wire        mem_valid;
    wire        mem_instr;
    wire        mem_ready;
    wire [31:0] mem_addr;
    wire [31:0] mem_wdata;
    wire [3:0]  mem_wstrb;
    wire [31:0] mem_rdata;

    // Instantiate the CPU
    picorv32 #(
        .PROGADDR_RESET(32'h00000000)
    ) cpu (
        .clk         (CLOCK_50),
        .resetn      (resetn),
        .mem_valid   (mem_valid),
        .mem_instr   (mem_instr),
        .mem_ready   (mem_ready),
        .mem_addr    (mem_addr),
        .mem_wdata   (mem_wdata),
        .mem_wstrb   (mem_wstrb),
        .mem_rdata   (mem_rdata),

        // Unused PicoRV32 interfaces
        .trap        (),    // Not used
        .mem_la_read (),
        .mem_la_write(),
        .mem_la_addr (),
        .mem_la_wdata(),
        .mem_la_wstrb(),
        .irq         (32'b0),
        .eoi         ()
    );

    // Instantiate simple memory
    simple_memory mem (
        .clk        (CLOCK_50),
        .resetn     (resetn),
        .mem_valid  (mem_valid),
        .mem_instr  (mem_instr),
        .mem_ready  (mem_ready),
        .mem_addr   (mem_addr),
        .mem_wdata  (mem_wdata),
        .mem_wstrb  (mem_wstrb),
        .mem_rdata  (mem_rdata),
		.LEDR	    (LEDR),
        .SW         (SW)
    );


endmodule
